1 - Remo√ß√£o do atributo PField.many
	O atributo √© atualmente utilizado para especificar quantas vezes a lista ir√° se repetir @Many(repeated=x). 
	Ele foi adicionado para permitir que elementos possam ser adicionados ap√≥s a posi√ß√£o da lista, de uma forma 
	que quem leia a String saiba diferenciar onde termina a lista e onde come√ßa o pr√≥ximo elemento. Por√©m, desde 
	que o Parser foi alterado para funcionar atrav√©s de posi√ß√µes especificadas (position=x), n√£o √© mais necess√°rio 
	usar o many com repeated, visto que um pr√≥ximo elemento da lista teria sua pr√≥pria posi√ß√£o exata j√° especificada.
	
	O problema √© que devemos preencher o espa√ßo entre o fim da lista e o pr√≥ximo elemento, e esse espa√ßo n√£o pode ser 
	preenchido simplesmente com " ", pois ele deve ser preenchido com o nullVaue dos elementos da lista, pois dessa 
	forma que ler saber√° de que se trata de um elemento nulo e poder√° parar de iterar pela lista. caso contr√°rio quem 
	lesse a string gerada poderia preencher uma lista com v√°rios elementos vazios, o que seria indesejado.
	
	Uma solu√ß√£o pensada √© que ao adicionar a lista, quando ela acabar, deve ser adicionado o nullValue dos valores da lista 
	at√© a posi√ß√£o do pr√≥ximo elemento. Para tanto, ser√° necess√°rio saber qual √© a posi√ß√£o do pr√≥ximo elemento no momento 
	em que se popula a lista. E para tanto parece ser necess√°rio realizar uma ordena√ß√£o dos PFields por position, permitindo 
	assim saber qual o pr√≥ximo elemento e sua posi√ß√£o.

2 - Tratamento de tipos
	Atualmente √© suportado apenas String, Objetos, List<String> e List<Objetos>.
	Deve permitir todos os tipos primitivos, e tambem java.util.Date. Para Date, deixar configur√°vel um SimpleDateFormatter 
	que ser√° utilizado no parse da String pro objeto e vice-versa. (pensar na possibilidade de deixar esse formatter global 
	(para todos os parses) e tambem configuravel para um parse especifico (talevz um metodo sobrescrito recebendo um 
	formatter))
	
	-REMOVER formatvalue() que È usado no toText. usar o formatter
		
	
	
3 - Pensar sobre alteracao no ParseException
	Talvez seja melhor permitir que a ParseException tenha um construtor a mais que receba um Throwable para aninhar a 
	exception original que a causou. Atualmente se ocorre um ClassCastException por exemplo, eu dou um catch nela e 
	lanco uma ParseException com mensagem apropriada. Mas talvez seja melhor, alem disso, deixar a exception original 
	como root cause da ParseException, pra facilitar identificacao do problema caso ocorra.
	
