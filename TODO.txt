1 - Remo√ß√£o do atributo PField.many
	O atributo √© atualmente utilizado para especificar quantas vezes a lista ir√° se repetir @Many(repeated=x). 
	Ele foi adicionado para permitir que elementos possam ser adicionados ap√≥s a posi√ß√£o da lista, de uma forma 
	que quem leia a String saiba diferenciar onde termina a lista e onde come√ßa o pr√≥ximo elemento. Por√©m, desde 
	que o Parser foi alterado para funcionar atrav√©s de posi√ß√µes especificadas (position=x), n√£o √© mais necess√°rio 
	usar o many com repeated, visto que um pr√≥ximo elemento da lista teria sua pr√≥pria posi√ß√£o exata j√° especificada.
	
	O problema √© que devemos preencher o espaco entre o fim da lista e o proximo elemento, e esse espa√ßo n√£o pode ser 
	preenchido simplesmente com " ", pois ele deve ser preenchido com o nullVaue dos elementos da lista, pois dessa 
	forma que ler saber√° de que se trata de um elemento nulo e poder√° parar de iterar pela lista. caso contr√°rio quem 
	lesse a string gerada poderia preencher uma lista com v√°rios elementos vazios, o que seria indesejado.
	
	Uma solu√ß√£o pensada √© que ao adicionar a lista, quando ela acabar, deve ser adicionado o nullValue dos valores da lista 
	at√© a posi√ß√£o do pr√≥ximo elemento. Para tanto, ser√° necess√°rio saber qual √© a posi√ß√£o do pr√≥ximo elemento no momento 
	em que se popula a lista. E para tanto parece ser necess√°rio realizar uma ordena√ß√£o dos PFields por position, permitindo 
	assim saber qual o pr√≥ximo elemento e sua posi√ß√£o.

2 - Tratamento de tipos
		
	[ ] fazer controle de exception em cada convert() do typedefinitions. logar.
	
	[ ] fazer os testes para controle de erros nas conversoes.
	
	[ ] pensar sobre refatorar typeDefinitions: estou usando heranca. pensar sobre interface + composicao. observar que 
	no toText do tipo STRING por exemplo, eu converto pra Object (pois o pai recebe Object) e simplesmente converto pra 
	String de novo. nao faz sentido pra ele. È como um empty method.
		
	
3 - Pensar sobre alteracao no ParseException
	Talvez seja melhor permitir que a ParseException tenha um construtor a mais que receba um Throwable para aninhar a 
	exception original que a causou. Atualmente se ocorre um ClassCastException por exemplo, eu dou um catch nela e 
	lanco uma ParseException com mensagem apropriada. Mas talvez seja melhor, alem disso, deixar a exception original 
	como root cause da ParseException, pra facilitar identificacao do problema caso ocorra.
	
